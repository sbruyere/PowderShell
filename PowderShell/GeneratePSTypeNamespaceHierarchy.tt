<#@ template language="C#" debug="true" hostSpecific="true" #>
<#@ output extension=".cs" #>
<#@ import namespace="System" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Management.Automation" #>
<#@ import namespace="System.Security" #>
<#@ import namespace="System.Collections.Immutable" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="System.Management.Automation" #>
<#@ assembly name="System.Linq" #>
<#@ assembly name="System.Collections.Immutable" #>

// This file is automatically generated by a T4 template.
// Changes to this file may be overwritten if the T4 template is regenerated.

namespace PowderShell
{
    public partial class GlobalCollections
    {
        public static readonly NestedNamespaceAtom PSTypes =
        
<#
            var psTypes = CollectPSTypes();
            Write(psTypes.ToString());
#>;
    }

    
}

<#+
public class NestedNamespaceAtom : SortedDictionary<string, NestedNamespaceAtom>
    {
        public NestedNamespaceAtom() : base(StringComparer.OrdinalIgnoreCase) { }

        public void AddFullName(string fullname)
        {
            string[] atomicName = fullname.Split('.');

            NestedNamespaceAtom currentAtom = this;

            foreach (string atom in atomicName)
            {
                if (currentAtom.ContainsKey(atom))
                    currentAtom = currentAtom[atom];
                else
                    currentAtom = currentAtom[atom] = new NestedNamespaceAtom();
            }
        }

        public string GetFixedCaseFullname(string fullname)
        {
            List<string> fixedAtoms = new List<string>();
            string[] atomicName = fullname.Split('.');

            NestedNamespaceAtom currentAtom = this;

            bool broken = false;
            foreach (string atom in atomicName)
            {
                if (!broken && currentAtom.ContainsKey(atom))
                {
                    var keys = currentAtom.Keys;
                    var fixedKey = keys.FirstOrDefault(v => v.Equals(atom, StringComparison.OrdinalIgnoreCase));

                    fixedAtoms.Add(fixedKey);
                    currentAtom = currentAtom[atom];
                }
                else
                {
                    broken = true;
                    fixedAtoms.Add(atom);
                }
            }

            return string.Join(".", fixedAtoms);
        }

        public override string ToString()
        {
            var stringBuilder = new System.Text.StringBuilder();
            
            if (this.Count == 0)
            {
                return "new NestedNamespaceAtom()";
            } 
            else
            {
                stringBuilder.AppendLine("new NestedNamespaceAtom {");
                foreach (var atom in this)
                {
                    stringBuilder.AppendLine(Helpers.IndentLines(4, $"[\"{atom.Key}\"] = " + atom.Value.ToString() + ","));
                }
                stringBuilder.Append("}");
            }

            return stringBuilder.ToString();
        }
    }

    private NestedNamespaceAtom CollectPSTypes()
    {
        var rootAtom = new NestedNamespaceAtom();
        var defaultNamespaces = new List<string> { "System", "Microsoft" };

        using (var ps = PowerShell.Create())
        {
            ps.AddScript(@"
                [AppDomain]::CurrentDomain.GetAssemblies() |
                ForEach-Object {
                    $_.GetTypes() | Where-Object { $_.IsPublic -and $_.FullName } | ForEach-Object {
                        $_.FullName
                    }
                } | Sort-Object -Unique
            ");

            var results = ps.Invoke();
            foreach (PSObject result in results)
            {
                string formattedName = result.ToString();
                rootAtom.AddFullName(formattedName);

                foreach (var defNameSpace in defaultNamespaces)
                {
                    if (formattedName.StartsWith(defNameSpace))
                    {
                        string addName = formattedName.Substring(defNameSpace.Length + 1);
                        rootAtom.AddFullName(addName);
                    }
                }
            }
        }

        return rootAtom;
    }

    private static string EscapeString(string value)
    {
        if (value == null)
            return string.Empty;

        return SecurityElement.Escape(value).Replace("&#xA;", "\\n").Replace("&#xD;", "\\r").Replace("&#x9;", "\\t");
    }

    private static class Helpers
    {
        internal static string IndentLines(int indent, string code)
        {
            List<string> lines = code.Split(new string[] { "\r\n", "\r", "\n" }, StringSplitOptions.None).ToList();

            for (int i = 0; i < lines.Count; i++)
            {
                if (!string.IsNullOrWhiteSpace(lines[i]))
                    lines[i] = new string(' ', indent) + lines[i];
            }

            if (string.IsNullOrWhiteSpace(lines[lines.Count - 1]))
                lines.RemoveAt(lines.Count - 1);

            return string.Join("\r\n", lines);
        }
    }
#>
